# 깃헙 사용법에 대한 전략  
현재 우리가 사용하고 있는 방법은 gitflow 방법을 기반으로 하여 변형된 형태입니다.  

## 기존의 gitflow 방법
main에서 뻗어나온 develop이 존재함  
develop에서는 feature/기능명으로 하나의 기능을 작성하기 위한 브랜치가 뻗어나옴.  
develop으로 feature가 merge되고 출시를 준비하기 위해 release 브랜치가 뻗어나옴.  
release에서 준비가 다 되면 main과 develop 둘 다에 merge하고 main은 배포하고 develop은 다음 버전을 위한 기반 브랜치가 되어 다시 feature가 뻗어나감.  
배포 이후 main에서 문제가 발생한 경우 hotfix branch를 파서 해결하고 main 브랜치에 병합하고, develop에도 병합함.

기본적으로 모든 상황에 merge를 하면 된다고 보면 됨.  

### rebase를 쓸 수 있는 조건.
> - 개인이 작업하는 공간.
현재 공간을 기반으로 파생된 공간이 없음.  
> - 모두가 함께 공유하는 branch는 rebase 해버리면 히스토리가 뒤섞이면서 히스토리를 보고 현재를 이해하기 어려워지기 때문에 rebase를 하지 않음.  
> - 즉 feature 브랜치에서만 쓸 수 있다고 이해하면 됨.  

### rebase의 단점.  
언제 시작되었는지 히스토리를 없애고, 상당히 오래 걸린 작업이라도 최신에서 파생된 브랜치처럼 보이게 함.

### rebase의 장점.  
하나의 feature브랜치의 기록을 순수히 그 기록만 보이게 하기 때문에, 다른 곳에서 merge되어 들어온 기록이 보이지 않아 하나의 feature의 개발 경과를 쉽게 볼 수 있게 함.  

## rebase 허용과 금지의 선택 기준  
현재 팀에서 무엇을 중요시하느냐를 생각하면 됨.  
만약 언제 시작해서 얼마나 걸렸고 같은 기록 자체가 중요하다면 rebase를 하지 않기로 하면 됨.  
반대로 히스토리를 통해 하나의 기능별 개발 경과를 쉽게 확인할 수 있게 하고 싶다면 rebase를 사용하면 됨.


## 각 상황에서의 흐름

### 한 파트에서 develop으로 병합 이후

docs->develop이 된 경우 다른 곳에서는 어떻게 해야할까?  

- 업데이트 된 내용이 다른 파트의 개발에 영향을 미치는 경우  
> docs나 front가 속하는 part 레벨에서는 파트장이 develop의 변화를 살펴보고 각 파트에 develop을 merge할지 말지 결정한다.

- 각 파트간의 의존성이 심한 경우.
> develop을 merge 하지 않고 너무 오랜 시간이 지나서 develop의 최신 버전에 너무 뒤쳐진 경우  
너무 최신 버전과 동기화하지 않고 시간이 흐른 경우에는 차후에 대량의 충돌을 일으킬 가능성이 있기 때문에  
정기적으로(매일 아침 혹은 매주 월요일 아침) develop의 내용을 각 part로 merge 할 필요가 있음.

- 주요 기능 단위가 끝났을 때  
> develop에서 여러 part의 자잘한 작업들이 합쳐지다가 주요 기능이 구현되었고, 그것을 front에서 처리해야 할 필요가 생겨난 경우.


## 실제로 어떻게 하면 될까?
### 기능 개발 레벨
1. 새 브랜치 기반이 될 브랜치로 이동해서 최신화
2. 열심히 기능 작성. rebase해서 해결할지 merge를 해와서 본인의 개인 브랜치 기반을 최신화 할지는 본인의 선택
3. 다 작성하고 pull request를 하고 리뷰를 요청한다.

### 파트 최신화 레벨
전부 다 pull request로 요청해서 해결한다
