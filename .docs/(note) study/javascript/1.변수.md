### 변수 할당 방법  
```bash
var result = A + B;
```

### 식별자  
식별자 어떤 값을 구별해서 식별할 수 있는 고유한 이름.  
값이 저장되어 있는 메모리 주소와 매핑관계  
즉 값이 아니라 메모리 주소를 기억하고 있다.  
단순 변수 이름 뿐만 아니라 각종 함수 클래스 이름 모두 식별자.  
- 변수 함수 클래스 등의 이름과 같은 식별자는 네이밍 규칙을 준수해야 한다.  

### 변수 선언  
```bash
var score; 
let score;
const score;
```
단순 선언만 해둘 시에는 확보된 공간에 undefined라는 값이 암묵적으로 할당되어 초기화 된다.  
변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록된다.  
자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역  
자바 스크립트 엔진은 실행 컨텍스트를 통해 식별자와 스코프를 관리한다.  
변수 이름과 변수 값은 실행 컨텍스트 내에 키 / 값 형식인 객체로 등록되어 있다.

### 키워드를 사용한 변수 선언시  
1. 선언 단계 - 변수 이름 score를 등록한다.  
2. 초기화 단계 - score 변수에 암묵적으로 undefined를 할당해 초기화 한다

선언하지 않은 식별자를 사용하려는 경우 ReferenceError를 띄운다.

### 변수 선언의 실행 시점과 변수 호이스팅  

```bash
console.log(socre); // undefined

var score; //변수 선언문
```
자바스크립트는 모든 선언문을 찾아내 먼저 실행한다.  
이후 소스코드 평과과정이 끝나면 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.

이러한 것을 **호이스팅**이라고 한다.

- var, let, const, function, function*, class 키워드를 사용해서 선언하는 모든 식별자는 다 호이스팅 된다.

### 값의 할당
```bash
var score;
score = 80;

==

var score = 80;
```
두 문장은 같은 것 같지만, 늘 선언문이 먼저 실행되고
값의 대입은 선언문 이후 위에서부터 순차적으로 진행되기 때문에
하나로 되어있든 옆에 있든, 선언은 먼저 진행되고, 대입은 런타임에서 실행된다.

```bash
console.log(score); // undefined

score = 80;
var score; 

console.log(score); // 80
```
그래서 위의 코드가 에러나지 않고 처음은 undefined가  
두 번째로는 80이 출력된다.

### 값의 재할당
```bash
var score = 80;
score = 90;
```
이게 첫 재할당 같지만 사실 이미 선언문 선언하면서 undefined로 초기화하고  
score에 80을 할당한 것이기 때문에 계속 재할당을 경험하고 있었다.  

그러나 재할당 과정은 기존 메모리 공간에 80을 90으로 바꿔넣는 게 아니라,
새로운 공간에 새로운 값을 집어넣고 그 메모리 주소를 변수와 재매핑하는 것이다.
그러한 과정에서 그 어떤 식별자와도 연결되지 않은 메모리 공간은 가비지 콜렉터에 의해 메모리에서 자동 해제 된다.

값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면  
변수가 아니라 상수라 한다.  
ES6부터 const 키워드를 사용해 선언한 변수는 재할당이 금지된다.  
const 키워드는 반드시 상수만을 위해 사용하지는 않는다.  

### 식별자 네이밍 규칙

- 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어, 달러 기호를 포함할 수 있다.
- 단, 식별자는 숫자로 시작할 수 없다.
- 예약어는 식별자로 사용할 수 없다.

- 변수는 쉼표를 사용해 한 번에 선언할 수 있다.
- 유니코드 문자로 명명된 식별자는 사용할 수 있지만 바람직하지 않다.
- 대소문자를 구별한다.
- 변수의 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현해야 한다.

일반적으로 변수,함수 = 카멜  
생성자, 클래스 = 파스칼을 사용한다.